// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: models/netalloc/netalloc.proto

// Netalloc allows to disassociate topology from addressing in the network
// configuration. Instead of inserting specific IP/MAC addresses, VXLAN VNIs, etc.,
// into the configuration data for interfaces, routes, ARPs and other network
// objects, the addresses can be symbolic references into the pool of allocated
// addresses known to the netalloc plugin. To allocate a new address, an instance
// of the proto message AddressAllocation should be submitted into the vpp-agent
// through one of the supported NB transports (etcd, GRPC, ...) under the
// corresponding key. Network object which references (to-be) allocated address
// will have a dependency on the corresponding key-value instance of AddressAllocation
// and will read and apply the address only once it is available.
// The ability to separate addresses from the rest of the network configuration
// is especially useful in scenarios where IP address allocations are provided
// externally, for example by another control-plane agent or by CNI in
// containerized environments.

package netalloc

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// AddressType lists all different types of addresses that can be allocated
// and referenced from models of other plugins.
type AddressType int32

const (
	AddressType_UNDEFINED AddressType = 0
	// IPV4_ADDR = IPv4 address of an interface
	AddressType_IPV4_ADDR AddressType = 1
	// IPV4_GW = IPv4 address of a gateway set for a given interface
	AddressType_IPV4_GW AddressType = 2
	// IPV6_ADDR = IPv6 address of an interface
	AddressType_IPV6_ADDR AddressType = 3
	// IPV6_GW = IPv6 address of a gateway set for a given interface
	AddressType_IPV6_GW AddressType = 4
)

var AddressType_name = map[int32]string{
	0: "UNDEFINED",
	1: "IPV4_ADDR",
	2: "IPV4_GW",
	3: "IPV6_ADDR",
	4: "IPV6_GW",
}

var AddressType_value = map[string]int32{
	"UNDEFINED": 0,
	"IPV4_ADDR": 1,
	"IPV4_GW":   2,
	"IPV6_ADDR": 3,
	"IPV6_GW":   4,
}

func (x AddressType) String() string {
	return proto.EnumName(AddressType_name, int32(x))
}

func (AddressType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_871b6a8ed3ae2830, []int{0}
}

// IPAddressForm can be used in the references to allocated IP addresses
// to ask for a specific form in which the address should applied.
type IPAddressForm int32

const (
	IPAddressForm_DEFAULT IPAddressForm = 0
	// ADDR_ONLY = apply address without mask, e.g. 192.168.2.5
	IPAddressForm_ADDR_ONLY IPAddressForm = 1
	// ADDR_WITH_MASK = apply address including the mask of the network,
	// e.g. 192.168.2.5/24
	IPAddressForm_ADDR_WITH_MASK IPAddressForm = 2
	// ADDR_NET = apply network implied by the address,
	// e.g. for 192.168.2.10/24 apply 192.168.2.0/24
	IPAddressForm_ADDR_NET IPAddressForm = 3
	// SINGLE_ADDR_NET = apply address with an all-ones mask (i.e. /32 for IPv4,
	// /128 for IPv6), e.g. 192.168.2.5/32
	IPAddressForm_SINGLE_ADDR_NET IPAddressForm = 4
)

var IPAddressForm_name = map[int32]string{
	0: "DEFAULT",
	1: "ADDR_ONLY",
	2: "ADDR_WITH_MASK",
	3: "ADDR_NET",
	4: "SINGLE_ADDR_NET",
}

var IPAddressForm_value = map[string]int32{
	"DEFAULT":         0,
	"ADDR_ONLY":       1,
	"ADDR_WITH_MASK":  2,
	"ADDR_NET":        3,
	"SINGLE_ADDR_NET": 4,
}

func (x IPAddressForm) String() string {
	return proto.EnumName(IPAddressForm_name, int32(x))
}

func (IPAddressForm) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_871b6a8ed3ae2830, []int{1}
}

// AddressAllocation represents a single allocated IP address.
//
// To reference allocated address, instead of entering specific IP address
// for interface/route/ARP/..., use one of the following string templates prefixed
// with netalloc keyword "alloc":
//  a) full reference (for available address types and forms, see AddressType
//     and IPAddressForm above):
//        "alloc:<network_name>/<interface_name>/<address_type>/<address_form>"
//  b) apply default address form (depends on destination, e.g. interface IP
//     address will use ADDR_WITH_MASK):
//        "alloc:<network_name>/<interface_name>/<address-type>
//  c) IPv4 is the default address to pick up, so for IPv4 and default address
//     form, the <address-type> and <address-form> can be omitted:
//        "alloc:<network_name>/<interface_name>"
//  d) when interface is given (e.g. when asked for IP from interface model),
//     interface_name can be omitted:
//        "alloc:<network_name>/<address_type>/<address_form>
//  e) when interface is given and the default address form is suitable:
//        "alloc:<network_name>/<address_type>
//  f) when interface is given, IPv4 address is requested and the default form
//     is suitable, then just specify the network name:
//        "alloc:<network_name>"
type AddressAllocation struct {
	// NetworkName is some label assigned to the network where the IP address
	// was assigned to the given interface.
	// In theory, interface can have multiple IP adresses or there can be multiple
	// address allocators and the network name allows to separate them.
	NetworkName string `protobuf:"bytes,1,opt,name=network_name,json=networkName,proto3" json:"network_name,omitempty"`
	// InterfaceName is the logical VPP or Linux interface name for which the
	// address is allocated.
	InterfaceName string `protobuf:"bytes,2,opt,name=interface_name,json=interfaceName,proto3" json:"interface_name,omitempty"`
	// AddressType specifies the type of the address assigned to the interface.
	AddressType AddressType `protobuf:"varint,3,opt,name=address_type,json=addressType,proto3,enum=netalloc.AddressType" json:"address_type,omitempty"`
	// Address is IP or MAC or address of some other type, as given by AddressType
	// (see the field above).
	// If address is IP address but without a mask, the all-ones mask (/32 for
	// IPv4, /128 for IPv6) will be assumed.
	Address              string   `protobuf:"bytes,4,opt,name=address,proto3" json:"address,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AddressAllocation) Reset()         { *m = AddressAllocation{} }
func (m *AddressAllocation) String() string { return proto.CompactTextString(m) }
func (*AddressAllocation) ProtoMessage()    {}
func (*AddressAllocation) Descriptor() ([]byte, []int) {
	return fileDescriptor_871b6a8ed3ae2830, []int{0}
}
func (m *AddressAllocation) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AddressAllocation.Unmarshal(m, b)
}
func (m *AddressAllocation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AddressAllocation.Marshal(b, m, deterministic)
}
func (m *AddressAllocation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddressAllocation.Merge(m, src)
}
func (m *AddressAllocation) XXX_Size() int {
	return xxx_messageInfo_AddressAllocation.Size(m)
}
func (m *AddressAllocation) XXX_DiscardUnknown() {
	xxx_messageInfo_AddressAllocation.DiscardUnknown(m)
}

var xxx_messageInfo_AddressAllocation proto.InternalMessageInfo

func (m *AddressAllocation) GetNetworkName() string {
	if m != nil {
		return m.NetworkName
	}
	return ""
}

func (m *AddressAllocation) GetInterfaceName() string {
	if m != nil {
		return m.InterfaceName
	}
	return ""
}

func (m *AddressAllocation) GetAddressType() AddressType {
	if m != nil {
		return m.AddressType
	}
	return AddressType_UNDEFINED
}

func (m *AddressAllocation) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (*AddressAllocation) XXX_MessageName() string {
	return "netalloc.AddressAllocation"
}

type ConfigData struct {
	Addresses            []*AddressAllocation `protobuf:"bytes,10,rep,name=addresses,proto3" json:"addresses,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *ConfigData) Reset()         { *m = ConfigData{} }
func (m *ConfigData) String() string { return proto.CompactTextString(m) }
func (*ConfigData) ProtoMessage()    {}
func (*ConfigData) Descriptor() ([]byte, []int) {
	return fileDescriptor_871b6a8ed3ae2830, []int{1}
}
func (m *ConfigData) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ConfigData.Unmarshal(m, b)
}
func (m *ConfigData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ConfigData.Marshal(b, m, deterministic)
}
func (m *ConfigData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigData.Merge(m, src)
}
func (m *ConfigData) XXX_Size() int {
	return xxx_messageInfo_ConfigData.Size(m)
}
func (m *ConfigData) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigData.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigData proto.InternalMessageInfo

func (m *ConfigData) GetAddresses() []*AddressAllocation {
	if m != nil {
		return m.Addresses
	}
	return nil
}

func (*ConfigData) XXX_MessageName() string {
	return "netalloc.ConfigData"
}
func init() {
	proto.RegisterEnum("netalloc.AddressType", AddressType_name, AddressType_value)
	proto.RegisterEnum("netalloc.IPAddressForm", IPAddressForm_name, IPAddressForm_value)
	proto.RegisterType((*AddressAllocation)(nil), "netalloc.AddressAllocation")
	proto.RegisterType((*ConfigData)(nil), "netalloc.ConfigData")
}

func init() { proto.RegisterFile("models/netalloc/netalloc.proto", fileDescriptor_871b6a8ed3ae2830) }

var fileDescriptor_871b6a8ed3ae2830 = []byte{
	// 392 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x64, 0x92, 0xd1, 0x8e, 0x9a, 0x40,
	0x18, 0x85, 0x8b, 0x98, 0xaa, 0x3f, 0x6a, 0xe9, 0x34, 0x4d, 0x48, 0x9b, 0x18, 0x6b, 0xd2, 0xc4,
	0x98, 0x28, 0x89, 0x6d, 0x4d, 0x7b, 0x49, 0x0b, 0x5a, 0x52, 0x4b, 0x0d, 0x62, 0x4d, 0x7b, 0x43,
	0x06, 0x1d, 0x29, 0x29, 0x30, 0x04, 0xc6, 0x36, 0x3e, 0xd6, 0xbe, 0xc5, 0xbe, 0xc7, 0xbe, 0xc8,
	0x86, 0x01, 0xd1, 0xec, 0xde, 0xcd, 0x77, 0xce, 0xf9, 0xcf, 0x40, 0xfe, 0x81, 0x5e, 0x44, 0xf7,
	0x24, 0xcc, 0xd4, 0x98, 0x30, 0x1c, 0x86, 0x74, 0x57, 0x1d, 0x26, 0x49, 0x4a, 0x19, 0x45, 0xcd,
	0x33, 0xbf, 0x1a, 0xfb, 0x01, 0xfb, 0x73, 0xf4, 0x26, 0x3b, 0x1a, 0xa9, 0x3e, 0xf5, 0xa9, 0xca,
	0x03, 0xde, 0xf1, 0xc0, 0x89, 0x03, 0x3f, 0x15, 0x83, 0x83, 0x1b, 0x01, 0x9e, 0x6b, 0xfb, 0x7d,
	0x4a, 0xb2, 0x4c, 0xcb, 0xe7, 0x31, 0x0b, 0x68, 0x8c, 0xde, 0x40, 0x3b, 0x26, 0xec, 0x3f, 0x4d,
	0xff, 0xba, 0x31, 0x8e, 0x88, 0x22, 0xf4, 0x85, 0x61, 0xcb, 0x96, 0x4a, 0xcd, 0xc2, 0x11, 0x41,
	0x6f, 0xa1, 0x1b, 0xc4, 0x8c, 0xa4, 0x07, 0xbc, 0x23, 0x45, 0xa8, 0xc6, 0x43, 0x9d, 0x4a, 0xe5,
	0xb1, 0x8f, 0xd0, 0xc6, 0x45, 0xbd, 0xcb, 0x4e, 0x09, 0x51, 0xc4, 0xbe, 0x30, 0xec, 0x4e, 0x5f,
	0x4e, 0xaa, 0xef, 0x2f, 0x2f, 0x77, 0x4e, 0x09, 0xb1, 0x25, 0x7c, 0x01, 0xa4, 0x40, 0xa3, 0x44,
	0xa5, 0xce, 0x9b, 0xcf, 0x38, 0x58, 0x00, 0x7c, 0xa1, 0xf1, 0x21, 0xf0, 0x75, 0xcc, 0x30, 0xfa,
	0x04, 0xad, 0xd2, 0x20, 0x99, 0x02, 0x7d, 0x71, 0x28, 0x4d, 0x5f, 0x3f, 0xaa, 0xbf, 0xfc, 0x9b,
	0x7d, 0x49, 0x8f, 0x1c, 0x90, 0xae, 0xae, 0x47, 0x1d, 0x68, 0x6d, 0x2c, 0xdd, 0x98, 0x9b, 0x96,
	0xa1, 0xcb, 0x4f, 0x72, 0x34, 0x57, 0x3f, 0xdf, 0xbb, 0x9a, 0xae, 0xdb, 0xb2, 0x80, 0x24, 0x68,
	0x70, 0x5c, 0x6c, 0xe5, 0x5a, 0xe9, 0xcd, 0x0a, 0x4f, 0x2c, 0xbd, 0x59, 0xee, 0xd5, 0x47, 0x1e,
	0x74, 0xcc, 0x55, 0xd9, 0x3b, 0xa7, 0x69, 0x94, 0xbb, 0xba, 0x31, 0xd7, 0x36, 0x4b, 0xa7, 0x68,
	0xcd, 0x87, 0xdc, 0x1f, 0xd6, 0xf2, 0x97, 0x2c, 0x20, 0x04, 0x5d, 0x8e, 0x5b, 0xd3, 0xf9, 0xea,
	0x7e, 0xd7, 0xd6, 0xdf, 0xe4, 0x1a, 0x6a, 0x43, 0x93, 0x6b, 0x96, 0xe1, 0xc8, 0x22, 0x7a, 0x01,
	0xcf, 0xd6, 0xa6, 0xb5, 0x58, 0x1a, 0x6e, 0x25, 0xd6, 0x3f, 0x7f, 0xb8, 0xbd, 0xeb, 0x09, 0xbf,
	0xd5, 0xab, 0x5d, 0x87, 0x81, 0x8f, 0x19, 0x55, 0xff, 0x25, 0xc9, 0x18, 0xfb, 0x24, 0x66, 0x2a,
	0x4e, 0x02, 0xf5, 0xc1, 0xab, 0xf1, 0x9e, 0xf2, 0xa5, 0xbf, 0xbb, 0x0f, 0x00, 0x00, 0xff, 0xff,
	0x20, 0x7e, 0x4e, 0xba, 0x4f, 0x02, 0x00, 0x00,
}
