// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: models/netalloc/netalloc.proto

// Netalloc allows to disassociate topology from addressing in the network
// configuration. Instead of inserting specific IP/MAC addresses, VXLAN VNIs, etc.,
// into the configuration data for interfaces, routes, ARPs and other network
// objects, the addresses can be symbolic references into the pool of allocated
// addresses known to the netalloc plugin.
// To allocate a new address, an instance of the proto message AddressAllocation
// should be submitted into the vpp-agent through one of the supported NB
// transports (etcd, GRPC, ...) under the corresponding key. Network object which
// references (to-be) allocated address will have a dependency on the corresponding
// key-value instance of AddressAllocation and will read and apply the address
// only once it is available.
// The ability to separate addresses from the rest of the network configuration
// is especially useful in scenarios where IP address allocations are provided
// externally, for example by another control-plane agent, IPAM tool or by CNI
// in containerized environments.

package netalloc

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// AddressType lists all different types of addresses that can be allocated
// and referenced from models of other plugins.
type AddressType int32

const (
	AddressType_UNDEFINED AddressType = 0
	// IPV4_ADDR = IPv4 address of an interface
	AddressType_IPV4_ADDR AddressType = 1
	// IPV4_GW = IPv4 address of a gateway set for a given interface
	AddressType_IPV4_GW AddressType = 2
	// IPV6_ADDR = IPv6 address of an interface
	AddressType_IPV6_ADDR AddressType = 3
	// IPV6_GW = IPv6 address of a gateway set for a given interface
	AddressType_IPV6_GW AddressType = 4
)

var AddressType_name = map[int32]string{
	0: "UNDEFINED",
	1: "IPV4_ADDR",
	2: "IPV4_GW",
	3: "IPV6_ADDR",
	4: "IPV6_GW",
}

var AddressType_value = map[string]int32{
	"UNDEFINED": 0,
	"IPV4_ADDR": 1,
	"IPV4_GW":   2,
	"IPV6_ADDR": 3,
	"IPV6_GW":   4,
}

func (x AddressType) String() string {
	return proto.EnumName(AddressType_name, int32(x))
}

func (AddressType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_871b6a8ed3ae2830, []int{0}
}

// IPAddressForm can be used in descriptors whose models reference allocated IP
// addresses, to ask for a specific form in which the address should applied.
type IPAddressForm int32

const (
	IPAddressForm_UNDEFINED_FORM IPAddressForm = 0
	// ADDR_ONLY = apply address without mask, e.g. 192.168.2.5
	IPAddressForm_ADDR_ONLY IPAddressForm = 1
	// ADDR_WITH_MASK = apply address including the mask of the network,
	// e.g. 192.168.2.5/24
	IPAddressForm_ADDR_WITH_MASK IPAddressForm = 2
	// ADDR_NET = apply network implied by the address,
	// e.g. for 192.168.2.10/24 apply 192.168.2.0/24
	IPAddressForm_ADDR_NET IPAddressForm = 3
	// SINGLE_ADDR_NET = apply address with an all-ones mask (i.e. /32 for IPv4,
	// /128 for IPv6)
	IPAddressForm_SINGLE_ADDR_NET IPAddressForm = 4
)

var IPAddressForm_name = map[int32]string{
	0: "UNDEFINED_FORM",
	1: "ADDR_ONLY",
	2: "ADDR_WITH_MASK",
	3: "ADDR_NET",
	4: "SINGLE_ADDR_NET",
}

var IPAddressForm_value = map[string]int32{
	"UNDEFINED_FORM":  0,
	"ADDR_ONLY":       1,
	"ADDR_WITH_MASK":  2,
	"ADDR_NET":        3,
	"SINGLE_ADDR_NET": 4,
}

func (x IPAddressForm) String() string {
	return proto.EnumName(IPAddressForm_name, int32(x))
}

func (IPAddressForm) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_871b6a8ed3ae2830, []int{1}
}

// IPAddressSource can be used to remember the source of an IP address.
// (e.g. to distinguish allocated IP addresses from statically defined ones)
type IPAddressSource int32

const (
	IPAddressSource_UNDEFINED_SOURCE IPAddressSource = 0
	// STATIC is IP address statically assigned in the NB configuration.
	IPAddressSource_STATIC IPAddressSource = 1
	// FROM_DHCP is set when IP address is obtained from DHCP.
	IPAddressSource_FROM_DHCP IPAddressSource = 2
	// ALLOC_REF is a reference inside NB configuration to an allocated
	// IP address.
	IPAddressSource_ALLOC_REF IPAddressSource = 3
	// ALLOCATED IP address via netalloc.
	IPAddressSource_ALLOCATED IPAddressSource = 4
)

var IPAddressSource_name = map[int32]string{
	0: "UNDEFINED_SOURCE",
	1: "STATIC",
	2: "FROM_DHCP",
	3: "ALLOC_REF",
	4: "ALLOCATED",
}

var IPAddressSource_value = map[string]int32{
	"UNDEFINED_SOURCE": 0,
	"STATIC":           1,
	"FROM_DHCP":        2,
	"ALLOC_REF":        3,
	"ALLOCATED":        4,
}

func (x IPAddressSource) String() string {
	return proto.EnumName(IPAddressSource_name, int32(x))
}

func (IPAddressSource) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_871b6a8ed3ae2830, []int{2}
}

// AddressAllocation represents a single allocated IP address.
//
// To reference allocated address, instead of entering specific IP address
// for interface/route/ARP/..., use one of the following string templates prefixed
// with netalloc keyword "alloc":
//  a) full reference (for available address types see AddressType above):
//        "alloc:<network_name>/<interface_name>/<address_type>"
//  b) IPv4 is the default address to pick up, so for IPv4 the <address-type>
//     can be omitted:
//        "alloc:<network_name>/<interface_name>"
//  c) when interface is given (e.g. when asked for IP from interface model),
//     interface_name can be omitted:
//        "alloc:<network_name>/<address_type>"
//  d) when interface is given and IPv4 address is requested, then just specify
//      the network name:
//        "alloc:<network_name>"
type AddressAllocation struct {
	// NetworkName is some label assigned to the network where the IP address
	// was assigned to the given interface.
	// In theory, interface can have multiple IP adresses or there can be multiple
	// address allocators and the network name allows to separate them.
	// The network name is not allowed to contain forward slashes.
	NetworkName string `protobuf:"bytes,1,opt,name=network_name,json=networkName,proto3" json:"network_name,omitempty"`
	// InterfaceName is the logical VPP or Linux interface name for which the
	// address is allocated.
	InterfaceName string `protobuf:"bytes,2,opt,name=interface_name,json=interfaceName,proto3" json:"interface_name,omitempty"`
	// AddressType specifies the type of the address assigned to the interface.
	AddressType AddressType `protobuf:"varint,3,opt,name=address_type,json=addressType,proto3,enum=netalloc.AddressType" json:"address_type,omitempty"`
	// Address is IP or MAC or address of some other type, as given by AddressType
	// (see the field above).
	// If address is IP address but without a mask, the all-ones mask (/32 for
	// IPv4, /128 for IPv6) will be assumed.
	Address              string   `protobuf:"bytes,4,opt,name=address,proto3" json:"address,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AddressAllocation) Reset()         { *m = AddressAllocation{} }
func (m *AddressAllocation) String() string { return proto.CompactTextString(m) }
func (*AddressAllocation) ProtoMessage()    {}
func (*AddressAllocation) Descriptor() ([]byte, []int) {
	return fileDescriptor_871b6a8ed3ae2830, []int{0}
}
func (m *AddressAllocation) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AddressAllocation.Unmarshal(m, b)
}
func (m *AddressAllocation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AddressAllocation.Marshal(b, m, deterministic)
}
func (m *AddressAllocation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddressAllocation.Merge(m, src)
}
func (m *AddressAllocation) XXX_Size() int {
	return xxx_messageInfo_AddressAllocation.Size(m)
}
func (m *AddressAllocation) XXX_DiscardUnknown() {
	xxx_messageInfo_AddressAllocation.DiscardUnknown(m)
}

var xxx_messageInfo_AddressAllocation proto.InternalMessageInfo

func (m *AddressAllocation) GetNetworkName() string {
	if m != nil {
		return m.NetworkName
	}
	return ""
}

func (m *AddressAllocation) GetInterfaceName() string {
	if m != nil {
		return m.InterfaceName
	}
	return ""
}

func (m *AddressAllocation) GetAddressType() AddressType {
	if m != nil {
		return m.AddressType
	}
	return AddressType_UNDEFINED
}

func (m *AddressAllocation) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (*AddressAllocation) XXX_MessageName() string {
	return "netalloc.AddressAllocation"
}

// ConfigData wraps all configuration items exported by netalloc.
// TBD: VXLAN VNIs, memif IDs, etc.
type ConfigData struct {
	Addresses            []*AddressAllocation `protobuf:"bytes,10,rep,name=addresses,proto3" json:"addresses,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *ConfigData) Reset()         { *m = ConfigData{} }
func (m *ConfigData) String() string { return proto.CompactTextString(m) }
func (*ConfigData) ProtoMessage()    {}
func (*ConfigData) Descriptor() ([]byte, []int) {
	return fileDescriptor_871b6a8ed3ae2830, []int{1}
}
func (m *ConfigData) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ConfigData.Unmarshal(m, b)
}
func (m *ConfigData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ConfigData.Marshal(b, m, deterministic)
}
func (m *ConfigData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigData.Merge(m, src)
}
func (m *ConfigData) XXX_Size() int {
	return xxx_messageInfo_ConfigData.Size(m)
}
func (m *ConfigData) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigData.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigData proto.InternalMessageInfo

func (m *ConfigData) GetAddresses() []*AddressAllocation {
	if m != nil {
		return m.Addresses
	}
	return nil
}

func (*ConfigData) XXX_MessageName() string {
	return "netalloc.ConfigData"
}
func init() {
	proto.RegisterEnum("netalloc.AddressType", AddressType_name, AddressType_value)
	proto.RegisterEnum("netalloc.IPAddressForm", IPAddressForm_name, IPAddressForm_value)
	proto.RegisterEnum("netalloc.IPAddressSource", IPAddressSource_name, IPAddressSource_value)
	proto.RegisterType((*AddressAllocation)(nil), "netalloc.AddressAllocation")
	proto.RegisterType((*ConfigData)(nil), "netalloc.ConfigData")
}

func init() { proto.RegisterFile("models/netalloc/netalloc.proto", fileDescriptor_871b6a8ed3ae2830) }

var fileDescriptor_871b6a8ed3ae2830 = []byte{
	// 451 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x64, 0x92, 0xef, 0x6a, 0xd3, 0x50,
	0x18, 0xc6, 0x97, 0xa6, 0x6c, 0xeb, 0x9b, 0xb6, 0x3b, 0x1e, 0x15, 0x82, 0xc2, 0xa8, 0x03, 0xa1,
	0x14, 0xd6, 0xc0, 0xd4, 0xa1, 0x1f, 0x63, 0xfe, 0x74, 0xc1, 0x36, 0x29, 0x49, 0xe6, 0xd0, 0x2f,
	0xf1, 0xb4, 0x3d, 0x8d, 0xc1, 0x26, 0x27, 0xa4, 0xa7, 0xca, 0x2e, 0xcb, 0xbb, 0xf0, 0x3e, 0xbc,
	0x11, 0xc9, 0x49, 0x96, 0x16, 0xf7, 0x2d, 0xbf, 0xf7, 0x79, 0xde, 0xe7, 0xc9, 0x81, 0x17, 0xce,
	0x53, 0xb6, 0xa2, 0x9b, 0xad, 0x96, 0x51, 0x4e, 0x36, 0x1b, 0xb6, 0x6c, 0x3e, 0xc6, 0x79, 0xc1,
	0x38, 0xc3, 0xa7, 0x0f, 0xfc, 0xe2, 0x32, 0x4e, 0xf8, 0xf7, 0xdd, 0x62, 0xbc, 0x64, 0xa9, 0x16,
	0xb3, 0x98, 0x69, 0xc2, 0xb0, 0xd8, 0xad, 0x05, 0x09, 0x10, 0x5f, 0xd5, 0xe2, 0xc5, 0x6f, 0x09,
	0x9e, 0xe8, 0xab, 0x55, 0x41, 0xb7, 0x5b, 0xbd, 0xdc, 0x27, 0x3c, 0x61, 0x19, 0x7e, 0x05, 0xdd,
	0x8c, 0xf2, 0x5f, 0xac, 0xf8, 0x11, 0x65, 0x24, 0xa5, 0xaa, 0x34, 0x90, 0x86, 0x1d, 0x5f, 0xa9,
	0x67, 0x2e, 0x49, 0x29, 0x7e, 0x0d, 0xfd, 0x24, 0xe3, 0xb4, 0x58, 0x93, 0x25, 0xad, 0x4c, 0x2d,
	0x61, 0xea, 0x35, 0x53, 0x61, 0x7b, 0x0f, 0x5d, 0x52, 0xc5, 0x47, 0xfc, 0x3e, 0xa7, 0xaa, 0x3c,
	0x90, 0x86, 0xfd, 0xab, 0xe7, 0xe3, 0xe6, 0xff, 0xeb, 0xf2, 0xf0, 0x3e, 0xa7, 0xbe, 0x42, 0xf6,
	0x80, 0x55, 0x38, 0xa9, 0x51, 0x6d, 0x8b, 0xe4, 0x07, 0xbc, 0x98, 0x00, 0x18, 0x2c, 0x5b, 0x27,
	0xb1, 0x49, 0x38, 0xc1, 0x1f, 0xa0, 0x53, 0x0b, 0x74, 0xab, 0xc2, 0x40, 0x1e, 0x2a, 0x57, 0x2f,
	0x1f, 0xc5, 0xef, 0xdf, 0xe6, 0xef, 0xdd, 0xa3, 0x10, 0x94, 0x83, 0x7a, 0xdc, 0x83, 0xce, 0xad,
	0x6b, 0x5a, 0xb6, 0xe3, 0x5a, 0x26, 0x3a, 0x2a, 0xd1, 0x99, 0x7f, 0x7e, 0x1b, 0xe9, 0xa6, 0xe9,
	0x23, 0x09, 0x2b, 0x70, 0x22, 0x70, 0x72, 0x87, 0x5a, 0xb5, 0x76, 0x5d, 0x69, 0x72, 0xad, 0x5d,
	0x97, 0x5a, 0x7b, 0x94, 0x40, 0xcf, 0x99, 0xd7, 0xb9, 0x36, 0x2b, 0x52, 0x8c, 0xa1, 0xdf, 0xe4,
	0x46, 0xb6, 0xe7, 0xcf, 0xaa, 0xf0, 0x72, 0x37, 0xf2, 0xdc, 0xe9, 0x17, 0x24, 0x95, 0x16, 0x81,
	0x77, 0x4e, 0x78, 0x13, 0xcd, 0xf4, 0xe0, 0x13, 0x6a, 0xe1, 0x2e, 0x9c, 0x8a, 0x99, 0x6b, 0x85,
	0x48, 0xc6, 0x4f, 0xe1, 0x2c, 0x70, 0xdc, 0xc9, 0xd4, 0x8a, 0x9a, 0x61, 0x7b, 0xf4, 0x0d, 0xce,
	0x9a, 0xaa, 0x80, 0xed, 0x8a, 0x25, 0xc5, 0xcf, 0x00, 0xed, 0xcb, 0x02, 0xef, 0xd6, 0x37, 0x2c,
	0x74, 0x84, 0x01, 0x8e, 0x83, 0x50, 0x0f, 0x1d, 0x03, 0x49, 0x65, 0xb5, 0xed, 0x7b, 0xb3, 0xc8,
	0xbc, 0x31, 0xe6, 0xd5, 0x53, 0xf4, 0xe9, 0xd4, 0x33, 0x22, 0xdf, 0xb2, 0x91, 0xdc, 0xa0, 0x1e,
	0x5a, 0x26, 0x6a, 0x7f, 0x7c, 0xf7, 0xe7, 0xef, 0xb9, 0xf4, 0x55, 0x3b, 0x38, 0xaa, 0x4d, 0x12,
	0x13, 0xce, 0xb4, 0x9f, 0x79, 0x7e, 0x49, 0x62, 0x9a, 0x71, 0x8d, 0xe4, 0x89, 0xf6, 0xdf, 0x79,
	0x2e, 0x8e, 0xc5, 0x75, 0xbd, 0xf9, 0x17, 0x00, 0x00, 0xff, 0xff, 0x54, 0x3d, 0xf6, 0xbc, 0xb8,
	0x02, 0x00, 0x00,
}
