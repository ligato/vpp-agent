// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: models/netalloc/netalloc.proto

// Netalloc allows to disassociate topology from addressing in the network
// configuration. Instead of inserting specific IP/MAC addresses, VXLAN VNIs, etc.,
// into the configuration data for interfaces, routes, ARPs and other network
// objects, the addresses can be symbolic references into the pool of allocated
// addresses known to the netalloc plugin.
//
// The ability to separate addresses from the rest of the network configuration
// is especially useful in scenarios where address allocations are provided
// externally, for example by another control-plane agent, IPAM tool or by CNI
// in containerized environments.
//
// But for now, only model for IP address allocations has been implemented.
// To allocate a new IP address, an instance of the proto message IPAllocation
// should be submitted into the vpp-agent through one of the supported NB
// transports (etcd, GRPC, ...) under the corresponding key. Network object which
// references (to-be or already) allocated address will have a dependency on the
// corresponding key-value instance of IPAllocation and will read and apply the
// address only once it is available.

package netalloc

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// IPAddressForm can be used in descriptors whose models reference allocated IP
// addresses, to ask for a specific form in which the address should applied.
type IPAddressForm int32

const (
	IPAddressForm_UNDEFINED_FORM IPAddressForm = 0
	// ADDR_ONLY = apply address without mask, e.g. 192.168.2.5
	IPAddressForm_ADDR_ONLY IPAddressForm = 1
	// ADDR_WITH_MASK = apply address including the mask of the network,
	// e.g. 192.168.2.5/24
	IPAddressForm_ADDR_WITH_MASK IPAddressForm = 2
	// ADDR_NET = apply network implied by the address,
	// e.g. for 192.168.2.10/24 apply 192.168.2.0/24
	IPAddressForm_ADDR_NET IPAddressForm = 3
	// SINGLE_ADDR_NET = apply address with an all-ones mask (i.e. /32 for IPv4,
	// /128 for IPv6)
	IPAddressForm_SINGLE_ADDR_NET IPAddressForm = 4
)

var IPAddressForm_name = map[int32]string{
	0: "UNDEFINED_FORM",
	1: "ADDR_ONLY",
	2: "ADDR_WITH_MASK",
	3: "ADDR_NET",
	4: "SINGLE_ADDR_NET",
}

var IPAddressForm_value = map[string]int32{
	"UNDEFINED_FORM":  0,
	"ADDR_ONLY":       1,
	"ADDR_WITH_MASK":  2,
	"ADDR_NET":        3,
	"SINGLE_ADDR_NET": 4,
}

func (x IPAddressForm) String() string {
	return proto.EnumName(IPAddressForm_name, int32(x))
}

func (IPAddressForm) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_871b6a8ed3ae2830, []int{0}
}

// IPAddressSource can be used to remember the source of an IP address.
// (e.g. to distinguish allocated IP addresses from statically defined ones)
type IPAddressSource int32

const (
	IPAddressSource_UNDEFINED_SOURCE IPAddressSource = 0
	// STATIC is IP address statically assigned in the NB configuration.
	IPAddressSource_STATIC IPAddressSource = 1
	// FROM_DHCP is set when IP address is obtained from DHCP.
	IPAddressSource_FROM_DHCP IPAddressSource = 2
	// ALLOC_REF is a reference inside NB configuration to an allocated
	// IP address.
	IPAddressSource_ALLOC_REF IPAddressSource = 3
)

var IPAddressSource_name = map[int32]string{
	0: "UNDEFINED_SOURCE",
	1: "STATIC",
	2: "FROM_DHCP",
	3: "ALLOC_REF",
}

var IPAddressSource_value = map[string]int32{
	"UNDEFINED_SOURCE": 0,
	"STATIC":           1,
	"FROM_DHCP":        2,
	"ALLOC_REF":        3,
}

func (x IPAddressSource) String() string {
	return proto.EnumName(IPAddressSource_name, int32(x))
}

func (IPAddressSource) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_871b6a8ed3ae2830, []int{1}
}

// IPAllocation represents a single allocated IP address.
//
// To reference allocated address, instead of entering specific IP address
// for interface/route/ARP/..., use one of the following string templates
// prefixed with netalloc keyword "alloc" followed by colon:
//  a) reference IP address allocated for an interface:
//        "alloc:<network_name>/<interface_name>"
//  b) when interface is given (e.g. when asked for IP from interface model),
//     interface_name can be omitted:
//        "alloc:<network_name>"
//  c) reference default gateway IP address assigned to an interface:
//        "alloc:<network_name>/<interface_name>/GW"
//  d) when asking for GW IP for interface which is given, interface_name
//     can be omitted:
//        "alloc:<network_name>/GW"
type IPAllocation struct {
	// NetworkName is some label assigned to the network where the IP address
	// was assigned to the given interface.
	// In theory, interface can have multiple IP adresses or there can be multiple
	// address allocators and the network name allows to separate them.
	// The network name is not allowed to contain forward slashes.
	NetworkName string `protobuf:"bytes,1,opt,name=network_name,json=networkName,proto3" json:"network_name,omitempty"`
	// InterfaceName is the logical VPP or Linux interface name for which the
	// address is allocated.
	InterfaceName string `protobuf:"bytes,2,opt,name=interface_name,json=interfaceName,proto3" json:"interface_name,omitempty"`
	// Address is an IP addres allocated to the interface inside the given
	// network.
	// If the address is specified without a mask, the all-ones mask (/32 for
	// IPv4, /128 for IPv6) will be assumed.
	Address string `protobuf:"bytes,4,opt,name=address,proto3" json:"address,omitempty"`
	// Gw is the address of the default gateway assigned to the interface in
	// the given network.
	// If the address is specified without a mask, then either:
	//  a) the mask of the <address> is used provided that GW IP falls into the
	//     same network IP range, or
	//  b) the all-ones mask is used otherwise
	Gw                   string   `protobuf:"bytes,5,opt,name=gw,proto3" json:"gw,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *IPAllocation) Reset()         { *m = IPAllocation{} }
func (m *IPAllocation) String() string { return proto.CompactTextString(m) }
func (*IPAllocation) ProtoMessage()    {}
func (*IPAllocation) Descriptor() ([]byte, []int) {
	return fileDescriptor_871b6a8ed3ae2830, []int{0}
}
func (m *IPAllocation) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_IPAllocation.Unmarshal(m, b)
}
func (m *IPAllocation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_IPAllocation.Marshal(b, m, deterministic)
}
func (m *IPAllocation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IPAllocation.Merge(m, src)
}
func (m *IPAllocation) XXX_Size() int {
	return xxx_messageInfo_IPAllocation.Size(m)
}
func (m *IPAllocation) XXX_DiscardUnknown() {
	xxx_messageInfo_IPAllocation.DiscardUnknown(m)
}

var xxx_messageInfo_IPAllocation proto.InternalMessageInfo

func (m *IPAllocation) GetNetworkName() string {
	if m != nil {
		return m.NetworkName
	}
	return ""
}

func (m *IPAllocation) GetInterfaceName() string {
	if m != nil {
		return m.InterfaceName
	}
	return ""
}

func (m *IPAllocation) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *IPAllocation) GetGw() string {
	if m != nil {
		return m.Gw
	}
	return ""
}

func (*IPAllocation) XXX_MessageName() string {
	return "netalloc.IPAllocation"
}

// ConfigData wraps all configuration items exported by netalloc.
// TBD: MACs, VXLAN VNIs, memif IDs, etc.
type ConfigData struct {
	IpAddresses          []*IPAllocation `protobuf:"bytes,10,rep,name=ip_addresses,json=ipAddresses,proto3" json:"ip_addresses,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *ConfigData) Reset()         { *m = ConfigData{} }
func (m *ConfigData) String() string { return proto.CompactTextString(m) }
func (*ConfigData) ProtoMessage()    {}
func (*ConfigData) Descriptor() ([]byte, []int) {
	return fileDescriptor_871b6a8ed3ae2830, []int{1}
}
func (m *ConfigData) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ConfigData.Unmarshal(m, b)
}
func (m *ConfigData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ConfigData.Marshal(b, m, deterministic)
}
func (m *ConfigData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigData.Merge(m, src)
}
func (m *ConfigData) XXX_Size() int {
	return xxx_messageInfo_ConfigData.Size(m)
}
func (m *ConfigData) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigData.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigData proto.InternalMessageInfo

func (m *ConfigData) GetIpAddresses() []*IPAllocation {
	if m != nil {
		return m.IpAddresses
	}
	return nil
}

func (*ConfigData) XXX_MessageName() string {
	return "netalloc.ConfigData"
}
func init() {
	proto.RegisterEnum("netalloc.IPAddressForm", IPAddressForm_name, IPAddressForm_value)
	proto.RegisterEnum("netalloc.IPAddressSource", IPAddressSource_name, IPAddressSource_value)
	proto.RegisterType((*IPAllocation)(nil), "netalloc.IPAllocation")
	proto.RegisterType((*ConfigData)(nil), "netalloc.ConfigData")
}

func init() { proto.RegisterFile("models/netalloc/netalloc.proto", fileDescriptor_871b6a8ed3ae2830) }

var fileDescriptor_871b6a8ed3ae2830 = []byte{
	// 395 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x5c, 0x92, 0xcd, 0x6e, 0xd3, 0x40,
	0x10, 0xc7, 0x6b, 0xa7, 0x94, 0x76, 0xf2, 0xd1, 0xd5, 0x82, 0x90, 0xc5, 0xa1, 0x2a, 0x95, 0x90,
	0xaa, 0x4a, 0x8d, 0x25, 0x10, 0x07, 0x8e, 0xc6, 0x1f, 0xad, 0x85, 0x63, 0x07, 0xdb, 0x15, 0x82,
	0xcb, 0x6a, 0xe3, 0x6c, 0x96, 0x15, 0xb6, 0xd7, 0xb2, 0x37, 0xe4, 0xce, 0xd3, 0xf1, 0x1e, 0xbc,
	0x08, 0xca, 0x36, 0x31, 0x51, 0x6f, 0xf3, 0xfb, 0xfb, 0x37, 0x9a, 0xb1, 0x66, 0xe1, 0xa2, 0x92,
	0x4b, 0x56, 0x76, 0x76, 0xcd, 0x14, 0x2d, 0x4b, 0x59, 0xf4, 0xc5, 0xb4, 0x69, 0xa5, 0x92, 0xf8,
	0x74, 0xcf, 0xaf, 0x6f, 0xb9, 0x50, 0x3f, 0xd6, 0x8b, 0x69, 0x21, 0x2b, 0x9b, 0x4b, 0x2e, 0x6d,
	0x2d, 0x2c, 0xd6, 0x2b, 0x4d, 0x1a, 0x74, 0xf5, 0xd8, 0x78, 0xf5, 0xdb, 0x80, 0x51, 0x38, 0x77,
	0xb6, 0xad, 0x54, 0x09, 0x59, 0xe3, 0x37, 0x30, 0xaa, 0x99, 0xda, 0xc8, 0xf6, 0x27, 0xa9, 0x69,
	0xc5, 0x2c, 0xe3, 0xd2, 0xb8, 0x3e, 0x4b, 0x87, 0xbb, 0x2c, 0xa6, 0x15, 0xc3, 0x6f, 0x61, 0x22,
	0x6a, 0xc5, 0xda, 0x15, 0x2d, 0xd8, 0xa3, 0x64, 0x6a, 0x69, 0xdc, 0xa7, 0x5a, 0xb3, 0xe0, 0x39,
	0x5d, 0x2e, 0x5b, 0xd6, 0x75, 0xd6, 0xb1, 0xfe, 0xbe, 0x47, 0x3c, 0x01, 0x93, 0x6f, 0xac, 0x67,
	0x3a, 0x34, 0xf9, 0xe6, 0xea, 0x0e, 0xc0, 0x95, 0xf5, 0x4a, 0x70, 0x8f, 0x2a, 0x8a, 0x3f, 0xc2,
	0x48, 0x34, 0x64, 0xe7, 0xb2, 0xce, 0x82, 0xcb, 0xc1, 0xf5, 0xf0, 0xdd, 0xab, 0x69, 0xff, 0xcb,
	0x87, 0xfb, 0xa6, 0x43, 0xd1, 0x38, 0x7b, 0xf5, 0x46, 0xc0, 0x38, 0x9c, 0xef, 0x30, 0x90, 0x6d,
	0x85, 0x31, 0x4c, 0x1e, 0x62, 0xcf, 0x0f, 0xc2, 0xd8, 0xf7, 0x48, 0x90, 0xa4, 0x33, 0x74, 0x84,
	0xc7, 0x70, 0xe6, 0x78, 0x5e, 0x4a, 0x92, 0x38, 0xfa, 0x86, 0x8c, 0xad, 0xa2, 0xf1, 0x6b, 0x98,
	0xdf, 0x93, 0x99, 0x93, 0x7d, 0x46, 0x26, 0x1e, 0xc1, 0xa9, 0xce, 0x62, 0x3f, 0x47, 0x03, 0xfc,
	0x02, 0xce, 0xb3, 0x30, 0xbe, 0x8b, 0x7c, 0xd2, 0x87, 0xc7, 0x37, 0x5f, 0xe0, 0xbc, 0x1f, 0x95,
	0xc9, 0x75, 0x5b, 0x30, 0xfc, 0x12, 0xd0, 0xff, 0x61, 0x59, 0xf2, 0x90, 0xba, 0x3e, 0x3a, 0xc2,
	0x00, 0x27, 0x59, 0xee, 0xe4, 0xa1, 0x8b, 0x8c, 0xed, 0xe8, 0x20, 0x4d, 0x66, 0xc4, 0xbb, 0x77,
	0xe7, 0xc8, 0xd4, 0x9b, 0x44, 0x51, 0xe2, 0x92, 0xd4, 0x0f, 0xd0, 0xe0, 0xd3, 0x87, 0x3f, 0x7f,
	0x2f, 0x8c, 0xef, 0xf6, 0xc1, 0x01, 0x4b, 0xc1, 0xa9, 0x92, 0xf6, 0xaf, 0xa6, 0xb9, 0xa5, 0x9c,
	0xd5, 0xca, 0xa6, 0x8d, 0xb0, 0x9f, 0x3c, 0x85, 0xc5, 0x89, 0xbe, 0xe4, 0xfb, 0x7f, 0x01, 0x00,
	0x00, 0xff, 0xff, 0xd4, 0xfe, 0xe7, 0xce, 0x24, 0x02, 0x00, 0x00,
}
