// Copyright (c) 2018 Cisco and/or its affiliates.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at:
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package main

const Template = `
// Code generated by adapter-generator. DO NOT EDIT.

package adapter

import (
	"fmt"
	"github.com/ligato/cn-infra/datasync"
	. "github.com/ligato/cn-infra/kvscheduler/api"
	. "github.com/ligato/cn-infra/kvscheduler/value/protoval"

    {{- range $i, $path := .Imports }}
	"{{ $path }}"
	{{- end }}
)

////////// type-safe key-value pair with metadata //////////

type {{ .DescriptorName }}KVWithMetadata struct {
	Key      string
	Value    {{ .ValueT }}
	Metadata {{ .MetadataT }}
	Origin   ValueOrigin
}

////////// type-safe Descriptor interface //////////

type {{ .DescriptorName }}DescriptorAPI interface {
	GetName() string
	KeySelector(key string) bool
	NBKeyPrefixes() []string
	WithMetadata() (withMeta bool, customMapFactory MetadataMapFactory)
{{- if .IsProtoValue }}
	Build(key string, valueData {{ .ValueDataT }}) (value ProtoValue, err error)
{{- else }}
	Build(key string, valueData {{ .ValueDataT }}) (value {{ .ValueT }}, err error)
{{- end }}
	Add(key string, value {{ .ValueT }}) (metadata {{ .MetadataT }}, err error)
	Delete(key string, value {{ .ValueT }}, metadata {{ .MetadataT }}) error
	Modify(key string, oldValue, newValue {{ .ValueT }}, oldMetadata {{ .MetadataT }}) (newMetadata {{ .MetadataT }}, err error)
	ModifyHasToRecreate(key string, oldValue, newValue {{ .ValueT }}, metadata {{ .MetadataT }}) bool
	Update(key string, value {{ .ValueT }}, metadata {{ .MetadataT }}) error
	Dependencies(key string, value {{ .ValueT }}) []Dependency
	DerivedValues(key string, value {{ .ValueT }}) []KeyValuePair
	Dump(correlate []{{ .DescriptorName }}KVWithMetadata) ([]{{ .DescriptorName }}KVWithMetadata, error)
	DumpDependencies() []string
}

////////// Descriptor base implementation //////////

// {{ .DescriptorName }}DescriptorBase provides default(=empty) implementations
// for all the methods to extend from.
type {{ .DescriptorName }}DescriptorBase struct {
}

func (db *{{ .DescriptorName }}DescriptorBase) GetName() string {
	return "base"
}

func (db *{{ .DescriptorName }}DescriptorBase) KeySelector(key string) bool {
	return false
}

func (db *{{ .DescriptorName }}DescriptorBase) NBKeyPrefixes() []string {
	return nil
}

func (db *{{ .DescriptorName }}DescriptorBase) WithMetadata() (withMeta bool, customMapFactory MetadataMapFactory) {
	return false, nil
}

{{ if .IsProtoValue -}}
func (db *{{ .DescriptorName }}DescriptorBase) Build(key string, valueData {{ .ValueDataT }}) (value ProtoValue, err error) {
{{- if .FromDatasync }}
	// You can override specific methods of ProtoValue using embedding:
	//
	//	type MyProtoValue struct {
	//		ProtoValue
	//      typedMsg {{ .ValueDataT }}
	//	}
	//	
	//	// ... (override some methods)
	//
	//  return &MyProtoValue{ProtoValue: NewProtoValue(valueData), typedMsg: valueData}	, nil
	return NewProtoValue(valueData), nil
{{- else }}
	return nil, nil
{{- end }}
}
{{- else }}
func (db *{{ .DescriptorName }}DescriptorBase) Build(key string, valueData {{ .ValueDataT }}) (value {{ .ValueT }}, err error) {
	return nil, nil
}
{{- end }}

func (db *{{ .DescriptorName }}DescriptorBase) Add(key string, value {{ .ValueT }}) (metadata {{ .MetadataT }}, err error) {
	fmt.Printf("Create for key=%s is not implemented\n", key)
	return nil, nil
}

func (db *{{ .DescriptorName }}DescriptorBase) Delete(key string, value {{ .ValueT }}, metadata {{ .MetadataT }}) error {
	fmt.Printf("Delete for key=%s is not implemented\n", key)
	return nil
}

func (db *{{ .DescriptorName }}DescriptorBase) Modify(key string, oldValue, newValue {{ .ValueT }}, oldMetadata {{ .MetadataT }}) (newMetadata {{ .MetadataT }}, err error) {
	fmt.Printf("Modify for key=%s is not implemented\n", key)
	return nil, nil
}

func (db *{{ .DescriptorName }}DescriptorBase) ModifyHasToRecreate(key string, oldValue, newValue {{ .ValueT }}, metadata {{ .MetadataT }}) bool {
	return false
}

func (db *{{ .DescriptorName }}DescriptorBase) Update(key string, value {{ .ValueT }}, metadata {{ .MetadataT }}) error {
	fmt.Printf("Modify for key=%s is not implemented\n", key)
	return nil
}

func (db *{{ .DescriptorName }}DescriptorBase) Dependencies(key string, value {{ .ValueT }}) []Dependency {
	return nil
}

func (db *{{ .DescriptorName }}DescriptorBase) DerivedValues(key string, value {{ .ValueT }}) []KeyValuePair {
	return nil
}

func (db *{{ .DescriptorName }}DescriptorBase) Dump(correlate []{{ .DescriptorName }}KVWithMetadata) ([]{{ .DescriptorName }}KVWithMetadata, error) {
	fmt.Println("Dump is not implemented")
	return nil, nil
}

func (db *{{ .DescriptorName }}DescriptorBase) DumpDependencies() []string {
	return nil
}

////////// Descriptor adapter //////////

type {{ .DescriptorName }}DescriptorAdapter struct {
	descriptor {{ .DescriptorName }}DescriptorAPI
}

func New{{ .DescriptorName }}Descriptor(impl {{ .DescriptorName }}DescriptorAPI) KVDescriptor {
	return &{{ .DescriptorName }}DescriptorAdapter{descriptor: impl}
}

func (da *{{ .DescriptorName }}DescriptorAdapter) GetName() string {
	return da.descriptor.GetName()
}

func (da *{{ .DescriptorName }}DescriptorAdapter) KeySelector(key string) bool {
	return da.descriptor.KeySelector(key)
}

func (da *{{ .DescriptorName }}DescriptorAdapter) NBKeyPrefixes() []string {
	return da.descriptor.NBKeyPrefixes()
}

func (da *{{ .DescriptorName }}DescriptorAdapter) WithMetadata() (withMeta bool, customMapFactory MetadataMapFactory) {
	return da.descriptor.WithMetadata()
}

func (da *{{ .DescriptorName }}DescriptorAdapter) Build(key string, valueData interface{}) (value Value, err error) {
	typedValueData, err := castValueData(key, valueData)
	if err != nil {
		return nil, err
	}
	return da.descriptor.Build(key, typedValueData)
}

func (da *{{ .DescriptorName }}DescriptorAdapter) Add(key string, value Value) (metadata Metadata, err error) {
	typedValue, err := castValue(key, value)
	if err != nil {
		return nil, err
	}
	return da.descriptor.Add(key, typedValue)
}

func (da *{{ .DescriptorName }}DescriptorAdapter) Modify(key string, oldValue, newValue Value, oldMetadata Metadata) (newMetadata Metadata, err error) {
	oldTypedValue, err := castValue(key, oldValue)
	if err != nil {
		return nil, err
	}
	newTypedValue, err := castValue(key, newValue)
	if err != nil {
		return nil, err
	}
	typedOldMetadata, err := castMetadata(key, oldMetadata)
	if err != nil {
		return nil, err
	}
	return da.descriptor.Modify(key, oldTypedValue, newTypedValue, typedOldMetadata)
}

func (da *{{ .DescriptorName }}DescriptorAdapter) Delete(key string, value Value, metadata Metadata) error {
	typedValue, err := castValue(key, value)
	if err != nil {
		return err
	}
	typedMetadata, err := castMetadata(key, metadata)
	if err != nil {
		return err
	}
	return da.descriptor.Delete(key, typedValue, typedMetadata)
}

func (da *{{ .DescriptorName }}DescriptorAdapter) ModifyHasToRecreate(key string, oldValue, newValue Value, metadata Metadata) bool {
	oldTypedValue, err := castValue(key, oldValue)
	if err != nil {
		return true
	}
	newTypedValue, err := castValue(key, newValue)
	if err != nil {
		return true
	}
	typedMetadata, err := castMetadata(key, metadata)
	if err != nil {
		return true
	}
	return da.descriptor.ModifyHasToRecreate(key, oldTypedValue, newTypedValue, typedMetadata)
}

func (da *{{ .DescriptorName }}DescriptorAdapter) Update(key string, value Value, metadata Metadata) error {
	typedValue, err := castValue(key, value)
	if err != nil {
		return err
	}
	typedMetadata, err := castMetadata(key, metadata)
	if err != nil {
		return err
	}
	return da.descriptor.Update(key, typedValue, typedMetadata)
}

func (da *{{ .DescriptorName }}DescriptorAdapter) Dependencies(key string, value Value) []Dependency {
	typedValue, err := castValue(key, value)
	if err != nil {
		return nil
	}
	return da.descriptor.Dependencies(key, typedValue)
}

func (da *{{ .DescriptorName }}DescriptorAdapter) DerivedValues(key string, value Value) []KeyValuePair {
	typedValue, err := castValue(key, value)
	if err != nil {
		return nil
	}
	return da.descriptor.DerivedValues(key, typedValue)
}

func (da *{{ .DescriptorName }}DescriptorAdapter) Dump(correlate []KVWithMetadata) ([]KVWithMetadata, error) {
	var correlateWithType []{{ .DescriptorName }}KVWithMetadata
	for _, kvpair := range correlate {
		typedValue, err := castValue(kvpair.Key, kvpair.Value)
		if err != nil {
			continue
		}
		typedMetadata, err := castMetadata(kvpair.Key, kvpair.Metadata)
		if err != nil {
			continue
		}
		correlateWithType = append(correlateWithType,
			{{ .DescriptorName }}KVWithMetadata{
				Key:      kvpair.Key,
				Value:    typedValue,
				Metadata: typedMetadata,
				Origin:   kvpair.Origin,
			})
	}
	
	typedDump, err := da.descriptor.Dump(correlateWithType)
	if err != nil {
		return nil, err
	}
	var dump []KVWithMetadata
	for _, typedKVWithMetadata := range typedDump {
		kvWithMetadata := KVWithMetadata{
			Key:      typedKVWithMetadata.Key,
			Metadata: typedKVWithMetadata.Metadata,
			Origin:   typedKVWithMetadata.Origin,
			}
		{{- if .IsProtoValue }}
		kvWithMetadata.Value = NewProtoValue(typedKVWithMetadata.Value)
		{{- else }}
		kvWithMetadata.Value = typedKVWithMetadata.Value
		{{- end }}
		dump = append(dump, kvWithMetadata)
	}
	return dump, err
}

func (da *{{ .DescriptorName }}DescriptorAdapter) DumpDependencies() []string {
	return da.descriptor.DumpDependencies()
}

////////// Helper methods //////////

func castValueData(key string, valueData interface{}) ({{ .ValueDataT }}, error) {
{{- if .FromDatasync }}
	changeValue, isChange := valueData.(datasync.ChangeValue)
	if !isChange {
		return nil, ErrInvalidValueDataType(key)
	}
	protoMessage := &{{ .ValueDataBaseT }}{}
	err := changeValue.GetValue(protoMessage)
	if err != nil {
		return nil, err
	}
	return protoMessage, nil
{{- else }}
	typedValueData, ok := valueData.({{ .ValueDataT }})
	if !ok {
		return nil, ErrInvalidValueDataType(key)
	}
	return typedValueData, nil
{{- end }}
}

func castValue(key string, value Value) ({{ .ValueT }}, error) {
{{- if .IsProtoValue }}
	protoValue, isProto := value.(ProtoValue)
	if !isProto {
		return nil, ErrInvalidValueType(key, value)
	}
	protoWithType, ok := protoValue.GetProtoMessage().({{ .ValueT }})
	if !ok {
		return nil, ErrInvalidValueType(key, value)
	}
	return protoWithType, nil
{{- else }}
	typedValue, ok := value.({{ .ValueT }})
	if !ok {
		return nil, ErrInvalidValueType(key, value)
	}
	return typedValue, nil
{{- end }}
}

func castMetadata(key string, metadata Metadata) ({{ .MetadataT }}, error) {
	if metadata == nil {
		return nil, nil
	}
	typedMetadata, ok := metadata.({{ .MetadataT }})
	if !ok {
		return nil, ErrInvalidMetadataType(key)
	}
	return typedMetadata, nil
}
`
