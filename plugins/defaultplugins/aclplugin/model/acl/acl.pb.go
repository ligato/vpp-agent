// Code generated by protoc-gen-gogo.
// source: acl.proto
// DO NOT EDIT!

/*
Package acl is a generated protocol buffer package.

It is generated from these files:
	acl.proto

It has these top-level messages:
	AccessLists
*/
package acl

import "github.com/gogo/protobuf/proto"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal

type AclAction int32

const (
	AclAction_DENY   AclAction = 0
	AclAction_PERMIT AclAction = 1
)

var AclAction_name = map[int32]string{
	0: "DENY",
	1: "PERMIT",
}
var AclAction_value = map[string]int32{
	"DENY":   0,
	"PERMIT": 1,
}

func (x AclAction) String() string {
	return proto.EnumName(AclAction_name, int32(x))
}

// This is a top level container for Access Control Lists.
// It can have one or more Access Control Lists.
type AccessLists struct {
	Acl []*AccessLists_Acl `protobuf:"bytes,1,rep,name=acl" json:"acl,omitempty"`
}

func (m *AccessLists) Reset()         { *m = AccessLists{} }
func (m *AccessLists) String() string { return proto.CompactTextString(m) }
func (*AccessLists) ProtoMessage()    {}

func (m *AccessLists) GetAcl() []*AccessLists_Acl {
	if m != nil {
		return m.Acl
	}
	return nil
}

// An Access Control List(ACL) is an ordered list of Access List Rules. Each Access Control Rule has
// a list of match criteria and a list of actions.
type AccessLists_Acl struct {
	Rules []*AccessLists_Acl_Rule `protobuf:"bytes,1,rep,name=rules" json:"rules,omitempty"`
	// The name of access-list. A device MAY restrict the length
	// and value of this name, possibly spRule and special
	// characters are not allowed.
	AclName string `protobuf:"bytes,3,opt,name=acl_name,proto3" json:"acl_name,omitempty"`
	// The set of interfRules that has assigned this ACL on ingres or egress
	Interfaces *AccessLists_Acl_Interfaces `protobuf:"bytes,2,opt,name=interfaces" json:"interfaces,omitempty"`
}

func (m *AccessLists_Acl) Reset()         { *m = AccessLists_Acl{} }
func (m *AccessLists_Acl) String() string { return proto.CompactTextString(m) }
func (*AccessLists_Acl) ProtoMessage()    {}

func (m *AccessLists_Acl) GetRules() []*AccessLists_Acl_Rule {
	if m != nil {
		return m.Rules
	}
	return nil
}

func (m *AccessLists_Acl) GetInterfaces() *AccessLists_Acl_Interfaces {
	if m != nil {
		return m.Interfaces
	}
	return nil
}

// List of access list entries(Rule)
type AccessLists_Acl_Rule struct {
	Actions *AccessLists_Acl_Rule_Actions `protobuf:"bytes,2,opt,name=actions" json:"actions,omitempty"`
	Matches *AccessLists_Acl_Rule_Matches `protobuf:"bytes,3,opt,name=matches" json:"matches,omitempty"`
	// Access List entry that can define:
	// - IP4/IP6 src ip prefix
	// - src MAC address mask
	// - src MAC address value
	// - can be used only for static ACLs.
	// A unique name identifying this Access List
	// Entry(Rule).
	RuleName string `protobuf:"bytes,5,opt,name=rule_name,proto3" json:"rule_name,omitempty"`
}

func (m *AccessLists_Acl_Rule) Reset()         { *m = AccessLists_Acl_Rule{} }
func (m *AccessLists_Acl_Rule) String() string { return proto.CompactTextString(m) }
func (*AccessLists_Acl_Rule) ProtoMessage()    {}

func (m *AccessLists_Acl_Rule) GetActions() *AccessLists_Acl_Rule_Actions {
	if m != nil {
		return m.Actions
	}
	return nil
}

func (m *AccessLists_Acl_Rule) GetMatches() *AccessLists_Acl_Rule_Matches {
	if m != nil {
		return m.Matches
	}
	return nil
}

// Definitions of action criteria for this Access List Rule
type AccessLists_Acl_Rule_Actions struct {
	AclAction AclAction `protobuf:"varint,1,opt,name=acl_action,proto3,enum=acl.AclAction" json:"acl_action,omitempty"`
}

func (m *AccessLists_Acl_Rule_Actions) Reset()         { *m = AccessLists_Acl_Rule_Actions{} }
func (m *AccessLists_Acl_Rule_Actions) String() string { return proto.CompactTextString(m) }
func (*AccessLists_Acl_Rule_Actions) ProtoMessage()    {}

// Definitions for match criteria for this Access List Rule
type AccessLists_Acl_Rule_Matches struct {
	IpRule    *AccessLists_Acl_Rule_Matches_IpRule    `protobuf:"bytes,1,opt,name=ip_rule" json:"ip_rule,omitempty"`
	MacipRule *AccessLists_Acl_Rule_Matches_MacIpRule `protobuf:"bytes,4,opt,name=macip_rule" json:"macip_rule,omitempty"`
}

func (m *AccessLists_Acl_Rule_Matches) Reset()         { *m = AccessLists_Acl_Rule_Matches{} }
func (m *AccessLists_Acl_Rule_Matches) String() string { return proto.CompactTextString(m) }
func (*AccessLists_Acl_Rule_Matches) ProtoMessage()    {}

func (m *AccessLists_Acl_Rule_Matches) GetIpRule() *AccessLists_Acl_Rule_Matches_IpRule {
	if m != nil {
		return m.IpRule
	}
	return nil
}

func (m *AccessLists_Acl_Rule_Matches) GetMacipRule() *AccessLists_Acl_Rule_Matches_MacIpRule {
	if m != nil {
		return m.MacipRule
	}
	return nil
}

// Access List entry that can define:
// - IP4/IP6 src/dst ip prefix- Internet Protocol number
// - Internet Protocol number
// - selected L4 headers:
//   * ICMP (type range)
//   * UDP (port range)
//   * TCP (port range, flags mask, flags value)
type AccessLists_Acl_Rule_Matches_IpRule struct {
	Ip    *AccessLists_Acl_Rule_Matches_IpRule_Ip    `protobuf:"bytes,1,opt,name=ip" json:"ip,omitempty"`
	Icmp  *AccessLists_Acl_Rule_Matches_IpRule_Icmp  `protobuf:"bytes,2,opt,name=icmp" json:"icmp,omitempty"`
	Tcp   *AccessLists_Acl_Rule_Matches_IpRule_Tcp   `protobuf:"bytes,4,opt,name=tcp" json:"tcp,omitempty"`
	Udp   *AccessLists_Acl_Rule_Matches_IpRule_Udp   `protobuf:"bytes,5,opt,name=udp" json:"udp,omitempty"`
	Other *AccessLists_Acl_Rule_Matches_IpRule_Other `protobuf:"bytes,3,opt,name=other" json:"other,omitempty"`
}

func (m *AccessLists_Acl_Rule_Matches_IpRule) Reset()         { *m = AccessLists_Acl_Rule_Matches_IpRule{} }
func (m *AccessLists_Acl_Rule_Matches_IpRule) String() string { return proto.CompactTextString(m) }
func (*AccessLists_Acl_Rule_Matches_IpRule) ProtoMessage()    {}

func (m *AccessLists_Acl_Rule_Matches_IpRule) GetIp() *AccessLists_Acl_Rule_Matches_IpRule_Ip {
	if m != nil {
		return m.Ip
	}
	return nil
}

func (m *AccessLists_Acl_Rule_Matches_IpRule) GetIcmp() *AccessLists_Acl_Rule_Matches_IpRule_Icmp {
	if m != nil {
		return m.Icmp
	}
	return nil
}

func (m *AccessLists_Acl_Rule_Matches_IpRule) GetTcp() *AccessLists_Acl_Rule_Matches_IpRule_Tcp {
	if m != nil {
		return m.Tcp
	}
	return nil
}

func (m *AccessLists_Acl_Rule_Matches_IpRule) GetUdp() *AccessLists_Acl_Rule_Matches_IpRule_Udp {
	if m != nil {
		return m.Udp
	}
	return nil
}

func (m *AccessLists_Acl_Rule_Matches_IpRule) GetOther() *AccessLists_Acl_Rule_Matches_IpRule_Other {
	if m != nil {
		return m.Other
	}
	return nil
}

// IP version used in this Access List Entry.
type AccessLists_Acl_Rule_Matches_IpRule_Ip struct {
	// Destination IPv4/IPv6 network
	DestinationNetwork string `protobuf:"bytes,1,opt,name=destination_network,proto3" json:"destination_network,omitempty"`
	// Destination IPv4/IPv6 network
	SourceNetwork string `protobuf:"bytes,2,opt,name=source_network,proto3" json:"source_network,omitempty"`
}

func (m *AccessLists_Acl_Rule_Matches_IpRule_Ip) Reset() {
	*m = AccessLists_Acl_Rule_Matches_IpRule_Ip{}
}
func (m *AccessLists_Acl_Rule_Matches_IpRule_Ip) String() string { return proto.CompactTextString(m) }
func (*AccessLists_Acl_Rule_Matches_IpRule_Ip) ProtoMessage()    {}

type AccessLists_Acl_Rule_Matches_IpRule_Icmp struct {
	// ICMPv6 flag, if false ICMPv4 will be used
	Icmpv6        bool                                                    `protobuf:"varint,1,opt,proto3" json:"Icmpv6,omitempty"`
	IcmpCodeRange *AccessLists_Acl_Rule_Matches_IpRule_Icmp_IcmpCodeRange `protobuf:"bytes,2,opt,name=icmp_code_range" json:"icmp_code_range,omitempty"`
	IcmpTypeRange *AccessLists_Acl_Rule_Matches_IpRule_Icmp_IcmpTypeRange `protobuf:"bytes,3,opt,name=icmp_type_range" json:"icmp_type_range,omitempty"`
}

func (m *AccessLists_Acl_Rule_Matches_IpRule_Icmp) Reset() {
	*m = AccessLists_Acl_Rule_Matches_IpRule_Icmp{}
}
func (m *AccessLists_Acl_Rule_Matches_IpRule_Icmp) String() string { return proto.CompactTextString(m) }
func (*AccessLists_Acl_Rule_Matches_IpRule_Icmp) ProtoMessage()    {}

func (m *AccessLists_Acl_Rule_Matches_IpRule_Icmp) GetIcmpCodeRange() *AccessLists_Acl_Rule_Matches_IpRule_Icmp_IcmpCodeRange {
	if m != nil {
		return m.IcmpCodeRange
	}
	return nil
}

func (m *AccessLists_Acl_Rule_Matches_IpRule_Icmp) GetIcmpTypeRange() *AccessLists_Acl_Rule_Matches_IpRule_Icmp_IcmpTypeRange {
	if m != nil {
		return m.IcmpTypeRange
	}
	return nil
}

// Inclusive range representing icmp codes to be used.
type AccessLists_Acl_Rule_Matches_IpRule_Icmp_IcmpCodeRange struct {
	// Lower boundary for range
	First uint32 `protobuf:"varint,1,opt,name=first,proto3" json:"first,omitempty"`
	// Upper boundary for range
	Last uint32 `protobuf:"varint,2,opt,name=last,proto3" json:"last,omitempty"`
}

func (m *AccessLists_Acl_Rule_Matches_IpRule_Icmp_IcmpCodeRange) Reset() {
	*m = AccessLists_Acl_Rule_Matches_IpRule_Icmp_IcmpCodeRange{}
}
func (m *AccessLists_Acl_Rule_Matches_IpRule_Icmp_IcmpCodeRange) String() string {
	return proto.CompactTextString(m)
}
func (*AccessLists_Acl_Rule_Matches_IpRule_Icmp_IcmpCodeRange) ProtoMessage() {}

type AccessLists_Acl_Rule_Matches_IpRule_Icmp_IcmpTypeRange struct {
	// Lower boundary for range
	First uint32 `protobuf:"varint,1,opt,name=first,proto3" json:"first,omitempty"`
	// Upper boundary for range
	Last uint32 `protobuf:"varint,2,opt,name=last,proto3" json:"last,omitempty"`
}

func (m *AccessLists_Acl_Rule_Matches_IpRule_Icmp_IcmpTypeRange) Reset() {
	*m = AccessLists_Acl_Rule_Matches_IpRule_Icmp_IcmpTypeRange{}
}
func (m *AccessLists_Acl_Rule_Matches_IpRule_Icmp_IcmpTypeRange) String() string {
	return proto.CompactTextString(m)
}
func (*AccessLists_Acl_Rule_Matches_IpRule_Icmp_IcmpTypeRange) ProtoMessage() {}

type AccessLists_Acl_Rule_Matches_IpRule_Tcp struct {
	DestinationPortRange *AccessLists_Acl_Rule_Matches_IpRule_Tcp_DestinationPortRange `protobuf:"bytes,1,opt,name=destination_port_range" json:"destination_port_range,omitempty"`
	SourcePortRange      *AccessLists_Acl_Rule_Matches_IpRule_Tcp_SourcePortRange      `protobuf:"bytes,2,opt,name=source_port_range" json:"source_port_range,omitempty"`
	// Binary mask for tcp flags to match. MSB order (FIN at position 0).
	// Applied as logical AND to tcp flags field of the packet being matched,
	// before it is compared with tcp-flags-value.
	TcpFlagsMask uint32 `protobuf:"varint,3,opt,name=tcp_flags_mask,proto3" json:"tcp_flags_mask,omitempty"`
	// Binary value for tcp flags to match. MSB order (FIN at position 0).
	// Before tcp-flags-value is compared with tcp flags field of the packet being matched,
	// tcp-flags-mask is applied to packet field value.
	TcpFlagsValue uint32 `protobuf:"varint,4,opt,name=tcp_flags_value,proto3" json:"tcp_flags_value,omitempty"`
}

func (m *AccessLists_Acl_Rule_Matches_IpRule_Tcp) Reset() {
	*m = AccessLists_Acl_Rule_Matches_IpRule_Tcp{}
}
func (m *AccessLists_Acl_Rule_Matches_IpRule_Tcp) String() string { return proto.CompactTextString(m) }
func (*AccessLists_Acl_Rule_Matches_IpRule_Tcp) ProtoMessage()    {}

func (m *AccessLists_Acl_Rule_Matches_IpRule_Tcp) GetDestinationPortRange() *AccessLists_Acl_Rule_Matches_IpRule_Tcp_DestinationPortRange {
	if m != nil {
		return m.DestinationPortRange
	}
	return nil
}

func (m *AccessLists_Acl_Rule_Matches_IpRule_Tcp) GetSourcePortRange() *AccessLists_Acl_Rule_Matches_IpRule_Tcp_SourcePortRange {
	if m != nil {
		return m.SourcePortRange
	}
	return nil
}

// Inclusive range representing destination ports to be used. When
// only lower-port is present, it represents a single port.
type AccessLists_Acl_Rule_Matches_IpRule_Tcp_DestinationPortRange struct {
	// Lower boundary for port.
	LowerPort uint32 `protobuf:"varint,1,opt,name=lower_port,proto3" json:"lower_port,omitempty"`
	// Upper boundary for port. If existing, the upper port must
	// be greater or equal to lower-port
	UpperPort uint32 `protobuf:"varint,2,opt,name=upper_port,proto3" json:"upper_port,omitempty"`
}

func (m *AccessLists_Acl_Rule_Matches_IpRule_Tcp_DestinationPortRange) Reset() {
	*m = AccessLists_Acl_Rule_Matches_IpRule_Tcp_DestinationPortRange{}
}
func (m *AccessLists_Acl_Rule_Matches_IpRule_Tcp_DestinationPortRange) String() string {
	return proto.CompactTextString(m)
}
func (*AccessLists_Acl_Rule_Matches_IpRule_Tcp_DestinationPortRange) ProtoMessage() {}

// Inclusive range representing source ports to be used.
// When only lower-port is present, it represents a single port.
type AccessLists_Acl_Rule_Matches_IpRule_Tcp_SourcePortRange struct {
	// Lower boundary for port.
	LowerPort uint32 `protobuf:"varint,1,opt,name=lower_port,proto3" json:"lower_port,omitempty"`
	// Upper boundary for port . If existing, the upper port
	// must be greater or equal to lower-port.
	UpperPort uint32 `protobuf:"varint,2,opt,name=upper_port,proto3" json:"upper_port,omitempty"`
}

func (m *AccessLists_Acl_Rule_Matches_IpRule_Tcp_SourcePortRange) Reset() {
	*m = AccessLists_Acl_Rule_Matches_IpRule_Tcp_SourcePortRange{}
}
func (m *AccessLists_Acl_Rule_Matches_IpRule_Tcp_SourcePortRange) String() string {
	return proto.CompactTextString(m)
}
func (*AccessLists_Acl_Rule_Matches_IpRule_Tcp_SourcePortRange) ProtoMessage() {}

type AccessLists_Acl_Rule_Matches_IpRule_Udp struct {
	DestinationPortRange *AccessLists_Acl_Rule_Matches_IpRule_Udp_DestinationPortRange `protobuf:"bytes,1,opt,name=destination_port_range" json:"destination_port_range,omitempty"`
	SourcePortRange      *AccessLists_Acl_Rule_Matches_IpRule_Udp_SourcePortRange      `protobuf:"bytes,2,opt,name=source_port_range" json:"source_port_range,omitempty"`
}

func (m *AccessLists_Acl_Rule_Matches_IpRule_Udp) Reset() {
	*m = AccessLists_Acl_Rule_Matches_IpRule_Udp{}
}
func (m *AccessLists_Acl_Rule_Matches_IpRule_Udp) String() string { return proto.CompactTextString(m) }
func (*AccessLists_Acl_Rule_Matches_IpRule_Udp) ProtoMessage()    {}

func (m *AccessLists_Acl_Rule_Matches_IpRule_Udp) GetDestinationPortRange() *AccessLists_Acl_Rule_Matches_IpRule_Udp_DestinationPortRange {
	if m != nil {
		return m.DestinationPortRange
	}
	return nil
}

func (m *AccessLists_Acl_Rule_Matches_IpRule_Udp) GetSourcePortRange() *AccessLists_Acl_Rule_Matches_IpRule_Udp_SourcePortRange {
	if m != nil {
		return m.SourcePortRange
	}
	return nil
}

// Inclusive range representing destination ports to be used. When
// only lower-port is present, it represents a single port.
type AccessLists_Acl_Rule_Matches_IpRule_Udp_DestinationPortRange struct {
	// Lower boundary for port.
	LowerPort uint32 `protobuf:"varint,1,opt,name=lower_port,proto3" json:"lower_port,omitempty"`
	// Upper boundary for port. If existing, the upper port must
	// be greater or equal to lower-port
	UpperPort uint32 `protobuf:"varint,2,opt,name=upper_port,proto3" json:"upper_port,omitempty"`
}

func (m *AccessLists_Acl_Rule_Matches_IpRule_Udp_DestinationPortRange) Reset() {
	*m = AccessLists_Acl_Rule_Matches_IpRule_Udp_DestinationPortRange{}
}
func (m *AccessLists_Acl_Rule_Matches_IpRule_Udp_DestinationPortRange) String() string {
	return proto.CompactTextString(m)
}
func (*AccessLists_Acl_Rule_Matches_IpRule_Udp_DestinationPortRange) ProtoMessage() {}

// Inclusive range representing source ports to be used.
// When only lower-port is present, it represents a single port.
type AccessLists_Acl_Rule_Matches_IpRule_Udp_SourcePortRange struct {
	// Lower boundary for port.
	LowerPort uint32 `protobuf:"varint,1,opt,name=lower_port,proto3" json:"lower_port,omitempty"`
	// Upper boundary for port . If existing, the upper port
	// must be greater or equal to lower-port.
	UpperPort uint32 `protobuf:"varint,2,opt,name=upper_port,proto3" json:"upper_port,omitempty"`
}

func (m *AccessLists_Acl_Rule_Matches_IpRule_Udp_SourcePortRange) Reset() {
	*m = AccessLists_Acl_Rule_Matches_IpRule_Udp_SourcePortRange{}
}
func (m *AccessLists_Acl_Rule_Matches_IpRule_Udp_SourcePortRange) String() string {
	return proto.CompactTextString(m)
}
func (*AccessLists_Acl_Rule_Matches_IpRule_Udp_SourcePortRange) ProtoMessage() {}

type AccessLists_Acl_Rule_Matches_IpRule_Other struct {
	// Internet Protocol number.
	Protocol uint32 `protobuf:"varint,1,opt,name=protocol,proto3" json:"protocol,omitempty"`
}

func (m *AccessLists_Acl_Rule_Matches_IpRule_Other) Reset() {
	*m = AccessLists_Acl_Rule_Matches_IpRule_Other{}
}
func (m *AccessLists_Acl_Rule_Matches_IpRule_Other) String() string { return proto.CompactTextString(m) }
func (*AccessLists_Acl_Rule_Matches_IpRule_Other) ProtoMessage()    {}

type AccessLists_Acl_Rule_Matches_MacIpRule struct {
	// Source IPv4/Ipv6 address
	SourceAddress string `protobuf:"bytes,1,opt,name=source_address,proto3" json:"source_address,omitempty"`
	// Source IPv4/Ipv6 address prefix
	SourceAddressPrefix uint32 `protobuf:"varint,2,opt,name=source_address_prefix,proto3" json:"source_address_prefix,omitempty"`
	// Source IEEE 802 MAC address.
	// Before source-mac-address is compared with source mac address field of the packet being matched,
	// source-mac-address-mask is applied to packet field value.
	SourceMacAddress string `protobuf:"bytes,3,opt,name=source_mac_address,proto3" json:"source_mac_address,omitempty"`
	// Source IEEE 802 MAC address mask.
	// Applied as logical AND with source mac address field of the packet being matched,
	// before it is compared with source-mac-address.
	SourceMacAddressMask string `protobuf:"bytes,4,opt,name=source_mac_address_mask,proto3" json:"source_mac_address_mask,omitempty"`
}

func (m *AccessLists_Acl_Rule_Matches_MacIpRule) Reset() {
	*m = AccessLists_Acl_Rule_Matches_MacIpRule{}
}
func (m *AccessLists_Acl_Rule_Matches_MacIpRule) String() string { return proto.CompactTextString(m) }
func (*AccessLists_Acl_Rule_Matches_MacIpRule) ProtoMessage()    {}

type AccessLists_Acl_Interfaces struct {
	Egress  []string `protobuf:"bytes,1,rep,name=egress" json:"egress,omitempty"`
	Ingress []string `protobuf:"bytes,2,rep,name=ingress" json:"ingress,omitempty"`
}

func (m *AccessLists_Acl_Interfaces) Reset()         { *m = AccessLists_Acl_Interfaces{} }
func (m *AccessLists_Acl_Interfaces) String() string { return proto.CompactTextString(m) }
func (*AccessLists_Acl_Interfaces) ProtoMessage()    {}

func init() {
	proto.RegisterEnum("acl.AclAction", AclAction_name, AclAction_value)
}
