syntax = "proto3";

package l3;

/* Static routes */
message StaticRoutes {
    message Route {
        uint32 vrf_id = 1;                   /* VRF identifier, field required for remote client. This value should be
                                                consistent with VRF ID in static route key. If it is not, value from
                                                key will be preffered and this field will be overriden.  */
        string description = 2;              /* optional description */
        string dst_ip_addr = 3;              /* ip address + prefix in format <address>/<prefix> */
        string next_hop_addr = 4;            /* next hop address */
        uint32 next_hop_vrf_id = 5;          /* Next hop VRF ID. Should be equal to the vrf_id unless inter-VRF
                                                routing is needed. */
        string outgoing_interface = 6;       /* outgoing interface name */
        uint32 lookup_vrf_id = 7;            /* Do a lookup in the specified VRF. In effect only if the next_hop_addr
                                                nor the outgoing_interface is set. */
        uint32 weight = 8;                   /* weight (used for unequal cost load balncing) */
        uint32 preference = 9;               /* The preference of the path. Lowest preference is preferred.  */
                                             /* Only paths with the best preference contribute to forwarding. */
                                             /* (a poor man's primary and backup) */
    }
    repeated Route routes = 1;                /* list of IP static routes */
}

/* IP ARP entries */
message ArpTable {
    message ArpEntry {
        string interface = 1;                          /* interface to which this APR entry applies */
        string ip_address = 2;                         /* IP address */
        string phys_address = 3;                       /* MAC address matching to the IP */
        bool static = 4;                               /* TRUE if this is a static ARP entry */
    }
    repeated ArpEntry arp_entries = 1;    /* list of ARP entries */
}

/* Proxy ARP ranges */
message ProxyArpRanges {
    message RangeList {
        string label = 1;                                /* unique proxy ARP range config identifier */
        message Range {
            string first_ip = 1;                        /* first (starting) IP address of the proxy ARP range */
            string last_ip = 2;                         /* last (ending) IP address of the proxy ARP range  */
        }
        repeated Range ranges = 2;
    }
    repeated RangeList range_lists = 1;                    /* list of proxy arp ranges */
}

/* Proxy ARP interfaces */
message ProxyArpInterfaces {
    message InterfaceList {
        string label = 1;                                /* unique proxy ARP interface config conigurator identifier */
        message Interface {
            string name = 1;                       /* name of the interface proxy arp is enabled for */
        }
        repeated Interface interfaces = 2;
    }
    repeated InterfaceList interface_lists = 1;           /* list of proxy ARP-enabled interfaces */
}

/* STN (Steal The NIC) feature table */
message STNTable {
    message STNTableEntry {
        string ip_address = 1;                          /* destination IP address of a packet that will be punted to specified interface in case it hasn't bee processed by VPP */
        string interface = 2;                           /* interface where the packets will be punted */
    }
    repeated STNTableEntry stn_entries = 1;     /* list of STN entries */
}